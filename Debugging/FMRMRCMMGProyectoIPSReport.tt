<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ output extension=".sql" #>
<#@ FMRMRCMMGProyectoIPS processor="FMRMRCMMGProyectoIPSDirectiveProcessor" requires="fileName='Sample.FMRMRCMMG_DSLProyIPS'" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Microsoft.VisualStudio.Modeling" #>

<#
    string dbName = "redbancaria"; 
#>
-- Generación automática: SQL
-- Base de Datos: <#= dbName #>

CREATE DATABASE IF NOT EXISTS <#= dbName #>;
USE <#= dbName #>;

<#
foreach (Elemento e in this.Tapiz.Elementoes)
{
    var entidad = e as Entidad;
    if (entidad == null) continue;
#>
-- Tabla: <#= entidad.nombre #>
CREATE TABLE IF NOT EXISTS <#= NormalizarNombre(entidad.nombre) #> (
    <# 
        // CLAVE PRIMARIA
        if (entidad.AtributoKey != null) {
            // Nota: Forzamos longitud 20 si es 0, para evitar errores en SQL con VARCHAR(0)
            int lenPk = (entidad.AtributoKey.longitud > 0) ? entidad.AtributoKey.longitud : 20;
    #>
    <#= NormalizarNombre(entidad.AtributoKey.nombre) #> <#= GetSqlType(entidad.AtributoKey.tipoDato, lenPk) #> NOT NULL,
    <# } #>

    <#
        // ATRIBUTOS
        foreach (Atributo attr in entidad.Atributo)
        {
            string nullStr = (attr.esNulo) ? "NULL" : "NOT NULL"; 
            string uniqueStr = (!attr.admiteRepetidos) ? "UNIQUE" : "";         
    #>
    <#= NormalizarNombre(attr.nombre) #> <#= GetSqlType(attr.tipoDato, attr.longitud) #> <#= nullStr #> <#= uniqueStr #>,
    <#
        }
    #>
    <# if (entidad.AtributoKey != null) { #>
    PRIMARY KEY (<#= NormalizarNombre(entidad.AtributoKey.nombre) #>)
    <# } #>
);

<#
} 
#>

<#
foreach (Elemento e in this.Tapiz.Elementoes)
{
    var rel = e as Relacion;
    if (rel == null) continue;

    // MAGIA: Recuperamos los enlaces que conectan esta relación con las entidades
    // Usamos DomainRoleInfo porque 'Relacion' no tiene una lista directa de Links, solo de Elementos.
    var links = DomainRoleInfo.GetElementLinks<EntidadReferencesRelacion1>(rel, EntidadReferencesRelacion1.RelacionDomainRoleId);
    
    // Una relación binaria debe tener exactamente 2 conexiones
    if (links.Count == 2) 
    {
        var link1 = links[0];
        var link2 = links[1];
        
        // Obtenemos las entidades de los extremos
        var ent1 = link1.Entidad;
        var ent2 = link2.Entidad;

        // VERIFICAR CARDINALIDAD N:M
        // Enum Cardinalidad: ceroAn=0, ceroAuno=1, unoAn=2, unoAuno=3
        // Consideramos "Muchos" si es ceroAn (0) o unoAn (2)
        bool esMuchos1 = (link1.cardinalidad == Cardinalidad.ceroAn || link1.cardinalidad == Cardinalidad.unoAn);
        bool esMuchos2 = (link2.cardinalidad == Cardinalidad.ceroAn || link2.cardinalidad == Cardinalidad.unoAn);

        if (esMuchos1 && esMuchos2)
        {
            // Validamos que ambas entidades tengan Clave Primaria definida para poder crear la FK
            if (ent1.AtributoKey != null && ent2.AtributoKey != null) {
#>
-- Tabla Relación N:M: <#= NormalizarNombre(rel.nombre) #>
CREATE TABLE IF NOT EXISTS <#= NormalizarNombre(rel.nombre) #> (
    -- Claves foráneas
    <#= NormalizarNombre(ent1.nombre) #>_FK <#= GetSqlType(ent1.AtributoKey.tipoDato, 20) #> NOT NULL,
    <#= NormalizarNombre(ent2.nombre) #>_FK <#= GetSqlType(ent2.AtributoKey.tipoDato, 20) #> NOT NULL,
    
    <# 
        // Atributos de la relación
        foreach(AtributoRelacion attrRel in rel.AtributoRelacion) {
            string nullStrRel = (attrRel.esNulo) ? "NULL" : "NOT NULL";
    #>
    <#= NormalizarNombre(attrRel.nombre) #> <#= GetSqlType(attrRel.tipoDato, attrRel.longitud) #> <#= nullStrRel #>,
    <# } #>

    FOREIGN KEY (<#= NormalizarNombre(ent1.nombre) #>_FK) REFERENCES <#= NormalizarNombre(ent1.nombre) #>(<#= NormalizarNombre(ent1.AtributoKey.nombre) #>),
    FOREIGN KEY (<#= NormalizarNombre(ent2.nombre) #>_FK) REFERENCES <#= NormalizarNombre(ent2.nombre) #>(<#= NormalizarNombre(ent2.AtributoKey.nombre) #>),
    PRIMARY KEY (<#= NormalizarNombre(ent1.nombre) #>_FK, <#= NormalizarNombre(ent2.nombre) #>_FK)
);
<#
            }
        }
    }
}
#>

DROP USER IF EXISTS 'appuser'@'localhost';
CREATE USER 'appuser'@'localhost' IDENTIFIED BY '1234';
GRANT ALL PRIVILEGES ON redbancaria.* TO 'appuser'@'localhost';

<#+
// HELPER PARA TIPOS DE DATOS
private string GetSqlType(TipoDatoEnum tipo, int longitud)
{
    // Ajuste de seguridad: si longitud es 0 o menor, ponemos 255 por defecto para evitar error SQL
    string len = (longitud > 0) ? longitud.ToString() : "255";

    switch (tipo)
    {
        case TipoDatoEnum.Entero: return "INTEGER";
        case TipoDatoEnum.Real: return "FLOAT";
        case TipoDatoEnum.Fecha: return "DATE";
        case TipoDatoEnum.Alfanumerico: return "VARCHAR(" + len + ")";
        default: return "VARCHAR(255)";
    }
}
#>

<#+
  // Función para normalizar nombres a camelCase (incluyendo espacios)
  private string NormalizarNombre(string nombre)
  {
      if (string.IsNullOrEmpty(nombre))
          return "campo";
      
      // Eliminar caracteres especiales excepto espacios y guiones bajos
      nombre = System.Text.RegularExpressions.Regex.Replace(nombre, "[^a-zA-Z0-9_ ]", "");
      
      // Dividir por espacios, guiones bajos o cambios de mayúsculas
      var partes = System.Text.RegularExpressions.Regex.Split(nombre, @"[\s_]+|(?=[A-Z])")
          .Where(p => ! string.IsNullOrEmpty(p))
          .ToList();
      
      if (partes.Count == 0)
          return "campo";
      
      // Primera parte en minúsculas, resto capitalizadas
      var resultado = partes[0].ToLower();
      
      for (int i = 1; i < partes.Count; i++)
      {
          resultado += char.ToUpper(partes[i][0]) + partes[i].Substring(1).ToLower();
      }
      
      return resultado;
  }
#>